# cloudbuild.yml
steps:
  # --- ステップ0: Firebase Web App 設定の取得 ---
  # Flutter Webアプリのビルドに必要なFirebase設定を取得します。
  # このステップは、Firebase Web Appが既に存在することを前提とします。
  # もし存在しない場合は、setup_infra.shでgcloud firebase apps web createを実行してください。
  - name: "gcr.io/cloud-builders/gcloud:latest"
    id: "Get Firebase Web App Config"
    entrypoint: "bash"
    args:
      - -c
      - |
        # プロジェクトのWebアプリIDを取得 (最初のWebアプリを使用)
        WEB_APP_ID=$(gcloud firebase apps web list --project=${PROJECT_ID} --format="value(appId)" | head -n 1)
        if [ -z "$WEB_APP_ID" ]; then
          echo "エラー: Firebase Web Appが見つかりません。FirebaseコンソールでWebアプリを追加するか、setup_infra.shを実行してください。"
          exit 1
        fi
        echo "Firebase Web App ID: ${WEB_APP_ID}"

        # Webアプリの設定を取得
        FIREBASE_CONFIG_JSON=$(gcloud firebase apps web describe ${WEB_APP_ID} --project=${PROJECT_ID} --format="json")

        # 必要な値を抽出し、環境変数として一時ファイルに書き出す
        # これらの変数は次のステップで --dart-define として渡されます
        echo "export FIREBASE_API_KEY=$(echo "${FIREBASE_CONFIG_JSON}" | jq -r '.apiKey')" >> /workspace/firebase_env.sh
        echo "export FIREBASE_APP_ID=$(echo "${FIREBASE_CONFIG_JSON}" | jq -r '.appId')" >> /workspace/firebase_env.sh
        echo "export FIREBASE_MESSAGING_SENDER_ID=$(echo "${FIREBASE_CONFIG_JSON}" | jq -r '.messagingSenderId')" >> /workspace/firebase_env.sh
        echo "export FIREBASE_PROJECT_ID=$(echo "${FIREBASE_CONFIG_JSON}" | jq -r '.projectId')" >> /workspace/firebase_env.sh
        echo "export FIREBASE_STORAGE_BUCKET=$(echo "${FIREBASE_CONFIG_JSON}" | jq -r '.storageBucket')" >> /workspace/firebase_env.sh
        echo "export FIREBASE_AUTH_DOMAIN=$(echo "${FIREBASE_CONFIG_JSON}" | jq -r '.authDomain')" >> /workspace/firebase_env.sh
        echo "Firebase config variables written to /workspace/firebase_env.sh"

  # --- ステップ1: フロントエンドのビルド ---
  - name: "ghcr.io/cirruslabs/flutter:3.35.3"
    id: "Build Frontend"
    entrypoint: "bash"
    args:
      - -c
      - |
        if [[ "${_DEPLOY_TARGET}" == "all" || "${_DEPLOY_TARGET}" == "app" ]]; then
          echo ">>> Building Flutter web app..."
          cd app
          # 前のステップで作成した環境変数を読み込む
          source /workspace/firebase_env.sh
          flutter pub get
          flutter build web --release \
            --dart-define="FIREBASE_API_KEY=${FIREBASE_API_KEY}" \
            --dart-define="FIREBASE_APP_ID=${FIREBASE_APP_ID}" \
            --dart-define="FIREBASE_MESSAGING_SENDER_ID=${FIREBASE_MESSAGING_SENDER_ID}" \
            --dart-define="FIREBASE_PROJECT_ID=${FIREBASE_PROJECT_ID}" \
            --dart-define="FIREBASE_STORAGE_BUCKET=${FIREBASE_STORAGE_BUCKET}" \
            --dart-define="FIREBASE_AUTH_DOMAIN=${FIREBASE_AUTH_DOMAIN}"
        else
          echo ">>> Skipping Flutter build for target: ${_DEPLOY_TARGET}"
        fi

  # --- ステップ2: Firebase Rules のデプロイ ---
  - name: "us-docker.pkg.dev/firebase-cli/us/firebase:14.15.2"
    id: "Deploy Firebase Rules"
    entrypoint: "bash"
    args:
      - -c
      - |
        if [[ "${_DEPLOY_TARGET}" == "all" || "${_DEPLOY_TARGET}" == "rules" ]]; then
          echo ">>> Firebase CLI version:"
          firebase --version || true
          echo ">>> Deploying Firestore and Storage rules..."
          firebase deploy --only firestore:rules,storage --project=${PROJECT_ID}
        else
          echo ">>> Skipping Firebase Rules deployment for target: ${_DEPLOY_TARGET}"
        fi

  # --- ステップ3: Cloud Functions Gen2 のデプロイ ---
  - name: "gcr.io/cloud-builders/gcloud:latest"
    id: "Deploy Cloud Functions"
    entrypoint: "bash"
    args:
      - -c
      - |
        if [[ "${_DEPLOY_TARGET}" == "all" || "${_DEPLOY_TARGET}" == "functions" ]]; then
          echo ">>> Deploying Cloud Functions gen2"
          gcloud --version
          gcloud functions deploy ${_FUNCTION_NAME} \
            --gen2 \
            --runtime=python313 \
            --region=${_REGION} \
            --source=./functions \
            --entry-point=generate_signed_url \
            --trigger-http \
            --project=${PROJECT_ID} \
            --set-env-vars="AUDIO_UPLOAD_BUCKET=${_AUDIO_UPLOAD_BUCKET},FIRESTORE_COLLECTION=${_FIRESTORE_COLLECTION}"
        else
          echo ">>> Skipping Cloud Functions deployment for target: ${_DEPLOY_TARGET}"
        fi

  # --- ステップ4: Backend イメージをビルドして Artifact Registry へプッシュ ---
  - name: "gcr.io/cloud-builders/docker:20.10.24"
    id: "Build backend image"
    entrypoint: "bash"
    args:
      - -c
      - |
        if [[ "${_DEPLOY_TARGET}" == "all" || "${_DEPLOY_TARGET}" == "backend" ]]; then
          IMAGE_TAG="${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REGISTRY_REPO}/${_BACKEND_SERVICE_NAME}:${SHORT_SHA}"
          echo ">>> Building image $${IMAGE_TAG}"
          docker build -t "$${IMAGE_TAG}" backend
          echo ">>> Pushing image $${IMAGE_TAG}"
          docker push "$${IMAGE_TAG}"
        fi

  # --- ステップ5: Cloud Run へデプロイ ---
  - name: "gcr.io/cloud-builders/gcloud:latest"
    id: "Deploy Backend to Cloud Run"
    entrypoint: "bash"
    args:
      - -c
      - |
        if [[ "${_DEPLOY_TARGET}" == "all" || "${_DEPLOY_TARGET}" == "backend" ]]; then
          IMAGE_TAG="${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REGISTRY_REPO}/${_BACKEND_SERVICE_NAME}:${SHORT_SHA}"
          echo ">>> Deploying to Cloud Run: ${_BACKEND_SERVICE_NAME}"
          gcloud run deploy ${_BACKEND_SERVICE_NAME} \
            --image "$${IMAGE_TAG}" \
            --platform managed \
            --region ${_REGION} \
            --service-account ${_BACKEND_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com \
            --no-allow-unauthenticated \
            --set-env-vars="GOOGLE_CLOUD_PROJECT_ID=${PROJECT_ID},AUDIO_UPLOAD_BUCKET=${_AUDIO_UPLOAD_BUCKET},PROCESSED_AUDIO_BUCKET=${_PROCESSED_AUDIO_BUCKET},GENERATED_IMAGE_BUCKET=${_GENERATED_IMAGE_BUCKET},FIRESTORE_COLLECTION=${_FIRESTORE_COLLECTION},SESSION_SERVICE=inmemory" \
            --project=${PROJECT_ID}
        fi

  # --- ステップ6: Eventarc トリガーの設定（gcloud） ---
  - name: "gcr.io/cloud-builders/gcloud:latest"
    id: "Configure Eventarc Trigger"
    entrypoint: "bash"
    args:
      - -c
      - |
        if [[ "${_DEPLOY_TARGET}" == "all" || "${_DEPLOY_TARGET}" == "backend" || "${_DEPLOY_TARGET}" == "trigger" ]]; then
          echo ">>> Configuring Eventarc trigger..."
          if ! gcloud eventarc triggers describe ${_TRIGGER_NAME} --location=${_REGION} --project=${PROJECT_ID} >/dev/null 2>&1; then
            echo "Trigger ${_TRIGGER_NAME} not found. Creating..."
            gcloud eventarc triggers create ${_TRIGGER_NAME} \
              --location=${_REGION} \
              --destination-run-service=${_BACKEND_SERVICE_NAME} \
              --destination-run-region=${_REGION} \
              --event-filters="type=google.cloud.storage.object.v1.finalized" \
              --event-filters="bucket=${_AUDIO_UPLOAD_BUCKET}" \
              --service-account=${_TRIGGER_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com \
              --project=${PROJECT_ID}
          else
            echo "Trigger ${_TRIGGER_NAME} already exists."
          fi
        fi

  # --- ステップ7: Firebase Hosting（frontend）デプロイ ---
  - name: "us-docker.pkg.dev/firebase-cli/us/firebase:14.15.2"
    id: "Deploy Frontend to Hosting"
    entrypoint: "bash"
    args:
      - -c
      - |
        if [[ "${_DEPLOY_TARGET}" == "all" || "${_DEPLOY_TARGET}" == "app" ]]; then
          echo ">>> Firebase CLI version:"
          firebase --version || true
          echo ">>> Deploying to Firebase Hosting..."
          firebase deploy --only hosting --project=${PROJECT_ID}
        fi

timeout: 1200s

options:
  logging: CLOUD_LOGGING_ONLY

substitutions:
  _DEPLOY_TARGET: "all"
  _REGION: "asia-northeast1"
  _BACKEND_SERVICE_NAME: "coco-ai-backend"
  _FUNCTION_NAME: "generate_signed_url"
  _BACKEND_SA_NAME: "coco-ai-backend-sa"
  _TRIGGER_SA_NAME: "coco-ai-eventarc-invoker"
  _TRIGGER_NAME: "trigger-coco-ai-storage"
  _FIRESTORE_COLLECTION: "jobs"
  _ARTIFACT_REGISTRY_REPO: "coco-ai"
  _AUDIO_UPLOAD_BUCKET: "coco-ai-input-audio"
  _PROCESSED_AUDIO_BUCKET: "coco-ai-output-narrations"
  _GENERATED_IMAGE_BUCKET: "coco-ai-output-images"
